"""
This file can be used to visualize some samples generated by the generate_dataset.py file
"""

import pickle as pkl

import h5py
import matplotlib.animation as ani
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import cm

MUSCLE_NAMES_FOR_ELBOW = [
    "CORB",
    "DELT1",
    "DELT2",
    "DELT3",
    "INFSP",
    "LAT1",
    "LAT2",
    "LAT3",
    "PECM1",
    "PECM2",
    "PECM3",
    "SUBSC",
    "SUPSP",
    "TMAJ",
    "TMIN",
    "ANC",
    "BIClong",
    "BICshort",
    "BRA",
    "BRD",
    "ECRL",
    "PT",
    "TRIlat",
    "TRIlong",
    "TRImed",
]
UPPER_ARM_LENGTH = 33
FOREARM_LENGTH = 26

plt.rcParams["lines.linewidth"] = 3.0
plt.rcParams["axes.titlesize"] = 20
plt.rcParams["figure.titlesize"] = 20
plt.rcParams["figure.labelsize"] = 20
plt.rcParams["axes.labelsize"] = 20
plt.rcParams["xtick.labelsize"] = 18
plt.rcParams["ytick.labelsize"] = 18

# to fit in frame
PLOT_SCALE = 113

# number of samples to show
NUM_TO_PLOT = 10

# max number of data points in the selected dataset
NUM_SAMPLES = 10

MAX_DURATION = 2  # in seconds

# ------------------------------------------------------------------------------------------------------
# helper functions


### Florian ###
def calculate_elbow_angles(
    true_shoulder, true_elbow, true_wrist, pred_shoulder, pred_elbow, pred_wrist
):
    # Calculate vectors for true data
    V1_true = true_elbow - true_shoulder  # Vector from shoulder to elbow
    V2_true = true_wrist - true_elbow  # Vector from elbow to wrist

    # Calculate vectors for predicted data
    V1_pred = pred_elbow - pred_shoulder  # Vector from shoulder to elbow
    V2_pred = pred_wrist - pred_elbow  # Vector from elbow to wrist

    # Compute dot products for true data
    dot_products_true = np.einsum("ij,ij->i", V1_true, V2_true)
    # Compute magnitudes for true data
    norms_V1_true = np.linalg.norm(V1_true, axis=1)
    norms_V2_true = np.linalg.norm(V2_true, axis=1)
    # Calculate cosines of angles for true data
    cos_theta_true = dot_products_true / (norms_V1_true * norms_V2_true)
    # Clip values to avoid numerical errors
    cos_theta_true = np.clip(cos_theta_true, -1.0, 1.0)
    # Compute angles in radians and then convert to degrees
    angles_true_deg = np.degrees(np.arccos(cos_theta_true))

    # Compute dot products for predicted data
    dot_products_pred = np.einsum("ij,ij->i", V1_pred, V2_pred)
    # Compute magnitudes for predicted data
    norms_V1_pred = np.linalg.norm(V1_pred, axis=1)
    norms_V2_pred = np.linalg.norm(V2_pred, axis=1)
    # Calculate cosines of angles for predicted data
    cos_theta_pred = dot_products_pred / (norms_V1_pred * norms_V2_pred)
    # Clip values to avoid numerical errors
    cos_theta_pred = np.clip(cos_theta_pred, -1.0, 1.0)
    # Compute angles in radians and then convert to degrees
    angles_pred_deg = np.degrees(np.arccos(cos_theta_pred))

    return angles_true_deg, angles_pred_deg


class TrajectoryVisualizer:
    def __init__(self, path_to_save=None, upper_arm_length=33):
        self.path_to_save = path_to_save
        self.upper_arm_length = upper_arm_length

    def _create_path_prefix(self, indx, input_data, vib_config):
        """Creates standardized path prefix for saving files."""
        if self.path_to_save is None:
            return None

        path_prefix = f"{self.path_to_save}/{indx}_{input_data}"
        if vib_config["is"]:
            freq = vib_config["VIB_FREQ"]
            path_prefix = f"{path_prefix}_vib_{freq}"
        return path_prefix

    def _setup_3d_plot(self):
        """Initialize 3D plot with standard settings."""
        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
        fig.set_size_inches(23, 13)

        ax.set_xlim(-50, 50)
        ax.set_ylim(-50, 50)
        ax.set_zlim(-50, 50)

        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")

        return fig, ax

    def _create_trajectory_lines(self, ax, coord_mode):
        """Create line and scatter objects for trajectories."""
        plot_elements = {}

        if coord_mode in ["both", "truth", "both_v"]:
            plot_elements["truth"] = {
                "scatter": ax.plot(
                    [], [], [], linestyle="", marker="o", markersize=10, color="blue"
                )[0],
                "line": ax.plot([], [], [], color="blue", label="Truth End-effector")[
                    0
                ],
            }

        if coord_mode in ["both", "pred", "both_v"]:
            plot_elements["pred"] = {
                "scatter": ax.plot(
                    [],
                    [],
                    [],
                    linestyle="",
                    marker="o",
                    markersize=10,
                    color="darkblue",
                )[0],
                "line": ax.plot(
                    [], [], [], color="darkblue", label="Predicted End-effector"
                )[0],
            }

        if coord_mode == "both_v":
            plot_elements["vib"] = {
                "scatter": ax.plot(
                    [], [], [], linestyle="", marker="o", markersize=10, color="cyan"
                )[0],
                "line": ax.plot(
                    [], [], [], color="cyan", label="Predicted End-effector Vib"
                )[0],
            }

        return plot_elements

    def _update_trajectory(self, elements, coords, frame_idx):
        """Update trajectory line and scatter for given frame."""
        elements["scatter"].set_data_3d(
            coords[frame_idx : frame_idx + 1, 0],
            coords[frame_idx : frame_idx + 1, 1],
            coords[frame_idx : frame_idx + 1, 2],
        )
        elements["line"].set_data_3d(
            coords[:frame_idx, 0], coords[:frame_idx, 1], coords[:frame_idx, 2]
        )

    def plot_3d_trajectory(self, data_dict, modes, vib_config, indx=0):
        """
        Plot 3D trajectory with optional animation.

        Args:
            data_dict: Dictionary containing trajectory data
            modes: Dictionary specifying plotting modes
            vib_config: Dictionary with vibration configuration
            indx: Index for saving files
        """
        fig, ax = self._setup_3d_plot()
        plot_elements = self._create_trajectory_lines(ax, modes["coord"])

        def animate(frame_idx):
            if "truth" in plot_elements:
                self._update_trajectory(
                    plot_elements["truth"], data_dict["wrist"], frame_idx
                )
            if "pred" in plot_elements:
                self._update_trajectory(
                    plot_elements["pred"], data_dict["pred_coords"], frame_idx
                )
            if "vib" in plot_elements:
                self._update_trajectory(
                    plot_elements["vib"], data_dict["pred_vib"], frame_idx
                )
            return list(plot_elements.values())

        if modes["data"] == "ELBOW":
            ax.view_init(elev=30, azim=-150)
        elif modes["data"] == "PCR":
            ax.view_init(elev=30, azim=-139)

        if modes["animate"]:
            frame_rate = 240
            num_frames = data_dict["wrist"].shape[0] - 1
            if modes["data"] == "FLAG":
                num_frames = min(num_frames, int(modes["MAX_DURATION"] * frame_rate))

            anim = ani.FuncAnimation(
                fig, animate, frames=num_frames, interval=1, repeat=True
            )

            path_prefix = self._create_path_prefix(indx, modes["data"], vib_config)
            if path_prefix:
                anim.save(
                    f"{path_prefix}_animation.gif",
                    writer=ani.PillowWriter(fps=frame_rate, bitrate=1800),
                )
        else:
            animate(data_dict["wrist"].shape[0] - 1)
            path_prefix = self._create_path_prefix(indx, modes["data"], vib_config)
            if path_prefix:
                plt.savefig(f"{path_prefix}_3D.png")

        return fig, ax

    def plot_2d_timeseries(self, data_dict, modes):
        """Plot 2D time series of trajectories."""
        # Implementation for 2D plotting
        pass


# def plotter(modes, path_to_save=None, **kwargs):
#     """Main plotting function that delegates to appropriate visualization methods."""
#     visualizer = TrajectoryVisualizer(path_to_save=path_to_save)

#     data_dict = {
#         "wrist": kwargs.get("wrist"),
#         "elbow": kwargs.get("elbow"),
#         "shoulder": kwargs.get("shoulder"),
#         "pred_coords": kwargs.get("pred_coords"),
#         "pred_vib": kwargs.get("pred_vib"),
#     }

#     if modes["plot"] in ["traj", "both"]:
#         visualizer.plot_3d_trajectory(
#             data_dict=data_dict,
#             modes=modes,
#             vib_config=kwargs.get("vib_config", {"is": False}),
#             indx=kwargs.get("indx", 0),
#         )

#     if modes["plot"] in ["muscles", "both"]:
#         visualizer.plot_2d_timeseries(data_dict, modes)

#     if modes["show"]:
#         plt.show()


def plot_movement(
    path_prefix,
    true_shoulder,
    true_elbow,
    true_wrist,
    pred_shoulder,
    pred_elbow,
    pred_wrist,
    angles_true=None,
    angles_pred=None,
):

    shoulder_elbow_dist = np.sqrt(
        np.sum((true_shoulder - true_elbow) ** 2, axis=1)
    ).mean()
    elbow_wrist_dist = np.sqrt(np.sum((true_elbow - true_wrist) ** 2, axis=1)).mean()
    print("True:", shoulder_elbow_dist, elbow_wrist_dist)
    shoulder_elbow_dist = np.sqrt(
        np.sum((pred_shoulder - pred_elbow) ** 2, axis=1)
    ).mean()
    elbow_wrist_dist = np.sqrt(np.sum((pred_elbow - pred_wrist) ** 2, axis=1)).mean()
    print("Pred:", shoulder_elbow_dist, elbow_wrist_dist)

    # shoulder_dist = np.sqrt(np.sum((true_shoulder - pred_shoulder) ** 2, axis=1)).mean()
    # elbow_dist = np.sqrt(np.sum((true_elbow - pred_elbow) ** 2, axis=1)).mean()
    # wrist_dist = np.sqrt(np.sum((true_wrist - pred_wrist) ** 2, axis=1)).mean()
    # print(shoulder_dist, elbow_dist, wrist_dist)

    # shoulder_dist = np.mean(true_shoulder - pred_shoulder, axis=0)
    # elbow_dist = np.mean(true_elbow - pred_elbow, axis=0)
    # wrist_dist = np.mean(true_wrist - pred_wrist, axis=0)
    # print(shoulder_dist, elbow_dist, wrist_dist)

    # for i in [50, 150, 400, 600, 800, 1000]:
    #     print(true_elbow[i], pred_elbow[i])
    #     print(true_elbow[i] - pred_elbow[i])

    plt.figure(figsize=(9, 6))
    plt.plot(
        np.sqrt(np.sum((pred_shoulder - pred_elbow) ** 2, axis=1)),
        label="pred shoul-elb dist",
    )
    plt.plot(
        np.sqrt(np.sum((true_shoulder - true_elbow) ** 2, axis=1)),
        label="true shoul-elb dist",
    )
    plt.plot(
        np.sqrt(np.sum((pred_elbow - pred_wrist) ** 2, axis=1)),
        label="pred elb-wrist dist",
    )
    plt.plot(
        np.sqrt(np.sum((true_elbow - true_wrist) ** 2, axis=1)),
        label="true elb-wrist dist",
    )
    plt.legend()
    plt.title("Elbow test sample")
    plt.xlabel("timecourse (no unit)")
    plt.ylabel("distance (cm)")
    plt.savefig(path_prefix + "_flo_joint_distance.png")

    fig = plt.figure(figsize=(22, 22))
    gs = fig.add_gridspec(3, 3)

    x_min = -50
    x_max = 50
    y_min = -50
    y_max = 50
    z_min = -50
    z_max = 50

    # Colors for true and predicted data
    true_color = "blue"
    pred_color = "red"

    time = np.linspace(0.0, 4.8, true_wrist.shape[0])

    # Subplot 1: 3D plot of true data only (blue)
    ax1 = fig.add_subplot(gs[0, 0], projection="3d")
    ax1.scatter(
        true_shoulder[:, 0],
        true_shoulder[:, 1],
        true_shoulder[:, 2],
        s=60,
        color="gray",
        label="True Shoulder",
        alpha=1,
    )
    ax1.scatter(
        true_elbow[:, 0],
        true_elbow[:, 1],
        true_elbow[:, 2],
        color=true_color,
        label="True Elbow",
        alpha=0.3,
    )
    ax1.scatter(
        true_wrist[:, 0],
        true_wrist[:, 1],
        true_wrist[:, 2],
        color="dark" + true_color,
        label="True Wrist",
        alpha=0.9,
    )
    ax1.plot(
        [true_shoulder[-1, 0], true_elbow[-1, 0], true_wrist[-1, 0]],
        [true_shoulder[-1, 1], true_elbow[-1, 1], true_wrist[-1, 1]],
        [true_shoulder[-1, 2], true_elbow[-1, 2], true_wrist[-1, 2]],
        color=true_color,
        label="True Arm Link",
        alpha=0.5,
    )
    ax1.view_init(elev=20, azim=-25)
    ax1.set_title("True Joints Position", fontsize=30)
    ax1.legend(loc="upper right", fontsize=20)
    ax1.set_xlim([x_min, x_max])
    ax1.set_ylim([y_min, y_max])
    ax1.set_zlim([z_min, z_max])
    # ax1.set_xticks([])
    # ax1.set_yticks([])
    # ax1.set_zticks([])
    # ax1.grid(visible=True)

    # Subplot 2: 2D true wrist X in blue and pred wrist X in red
    ax2 = fig.add_subplot(gs[1, 0])
    ax2.plot(time, pred_wrist[:, 0], color="dark" + pred_color, label="Pred X")
    ax2.plot(time, true_wrist[:, 0], color="dark" + true_color, label="True X")
    ax2.set_title("Wrist X over Time", fontsize=30)
    ax2.set_xlabel("Time (s)")
    ax2.set_ylabel("X Position (cm)")
    ax2.set_ylim([x_min, x_max])
    ax2.legend(fontsize=20)

    # Subplot 3: 2D true wrist Y in blue and pred wrist Y in red
    ax3 = fig.add_subplot(gs[1, 1])
    ax3.plot(time, pred_wrist[:, 1], color="dark" + pred_color, label="Pred Y")
    ax3.plot(time, true_wrist[:, 1], color="dark" + true_color, label="True Y")
    ax3.set_title("Wrist Y over Time", fontsize=30)
    ax3.set_xlabel("Time (s)")
    ax3.set_ylabel("Y Position (cm)")
    ax3.set_ylim([y_min, y_max])
    ax3.legend(fontsize=20)

    # Subplot 4: 2D true wrist Z in blue and pred wrist Z in red
    ax4 = fig.add_subplot(gs[1, 2])
    ax4.plot(time, pred_wrist[:, 2], color="dark" + pred_color, label="Pred Z")
    ax4.plot(time, true_wrist[:, 2], color="dark" + true_color, label="True Z")
    ax4.set_title("Wrist Z over Time", fontsize=30)
    ax4.set_xlabel("Time (s)")
    ax4.set_ylabel("Z Position (cm)")
    ax4.set_ylim([z_min, z_max])
    ax4.legend(fontsize=20)

    # Subplot 5: 3D plot of pred data only (red)
    ax5 = fig.add_subplot(gs[0, 1], projection="3d")
    ax5.scatter(
        pred_shoulder[:, 0],
        pred_shoulder[:, 1],
        pred_shoulder[:, 2],
        s=60,
        color="gray",
        label="Pred Shoulder",
        alpha=1,
    )
    ax5.scatter(
        pred_elbow[:, 0],
        pred_elbow[:, 1],
        pred_elbow[:, 2],
        color=pred_color,
        label="Pred Elbow",
        alpha=0.3,
    )
    ax5.scatter(
        pred_wrist[:, 0],
        pred_wrist[:, 1],
        pred_wrist[:, 2],
        color="dark" + pred_color,
        label="Pred Wrist",
        alpha=0.9,
    )
    ax5.plot(
        [pred_shoulder[-1, 0], pred_elbow[-1, 0], pred_wrist[-1, 0]],
        [pred_shoulder[-1, 1], pred_elbow[-1, 1], pred_wrist[-1, 1]],
        [pred_shoulder[-1, 2], pred_elbow[-1, 2], pred_wrist[-1, 2]],
        color=pred_color,
        label="Pred Arm Link",
        alpha=0.5,
    )
    ax5.view_init(elev=20, azim=-25)
    ax5.set_title("Predicted Joints Position", fontsize=30)
    ax5.legend(loc="upper right", fontsize=20)
    ax5.set_xlim([x_min, x_max])
    ax5.set_ylim([y_min, y_max])
    ax5.set_zlim([z_min, z_max])
    # ax5.set_xticks([])
    # ax5.set_yticks([])
    # ax5.set_zticks([])
    # ax5.grid(visible=True)

    # Subplot 6: 2D true elbow X in blue and pred elbow X in red
    ax6 = fig.add_subplot(gs[2, 0])
    ax6.plot(time, pred_elbow[:, 0], color=pred_color, label="Pred X")
    ax6.plot(time, true_elbow[:, 0], color=true_color, label="True X")
    ax6.set_title("Elbow X over Time", fontsize=30)
    ax6.set_xlabel("Time (s)")
    ax6.set_ylabel("X Position (cm)")
    ax6.set_ylim([x_min, x_max])
    ax6.legend(fontsize=20)

    # Subplot 7: 2D true elbow Y in blue and pred elbow Y in red
    ax7 = fig.add_subplot(gs[2, 1])
    ax7.plot(time, pred_elbow[:, 1], color=pred_color, label="Pred Y")
    ax7.plot(time, true_elbow[:, 1], color=true_color, label="True Y")
    ax7.set_title("Elbow Y over Time", fontsize=30)
    ax7.set_xlabel("Time (s)")
    ax7.set_ylabel("Y Position (cm)")
    ax7.set_ylim([y_min, y_max])
    ax7.legend(fontsize=20)

    # Subplot 8: 2D true elbow Z in blue and pred elbow Z in red
    ax8 = fig.add_subplot(gs[2, 2])
    ax8.plot(time, pred_elbow[:, 2], color=pred_color, label="Pred Z")
    ax8.plot(time, true_elbow[:, 2], color=true_color, label="True Z")
    ax8.set_title("Elbow Z over Time", fontsize=30)
    ax8.set_xlabel("Time (s)")
    ax8.set_ylabel("Z Position (cm)")
    ax8.set_ylim([z_min, z_max])
    ax8.legend(fontsize=20)

    if angles_pred is None:
        angles_true, angles_pred = calculate_elbow_angles(
            true_shoulder, true_elbow, true_wrist, pred_shoulder, pred_elbow, pred_wrist
        )
    # Subplot 9: elbow angle
    ax9 = fig.add_subplot(gs[0, 2])
    ax9.plot(time, angles_pred, color=pred_color, label="Pred angle")
    ax9.plot(time, angles_true, color=true_color, label="True angle")
    ax9.set_title("Elbow Angle over Time", fontsize=30)
    ax9.set_xlabel("Time (s)")
    ax9.set_ylabel("Angle (deg)")
    ax9.legend(fontsize=20)

    plt.tight_layout()
    plt.savefig(path_prefix + "_flo.png")


def plot_outputs(
    GT, prediction, prediction_vib=None, num=0, path_prefix=None, output_names=None
):
    """
    Plot time series for each dimension in GT along with predictions.

    Parameters:
    GT : np.ndarray
        Ground truth array of shape (time_steps, dimensions).
    prediction : np.ndarray
        Predicted values of shape (time_steps, dimensions).
    prediction_vib : np.ndarray, optional
        Alternative predicted values with vibration, same shape as GT.
    task : str, optional
        Task name for the title.
    path_to_save : str, optional
        Path to save the figure.
    """
    # sns.set_style("whitegrid")
    # plt.rcParams.update({'font.size': 12, 'axes.labelsize': 14, 'axes.titlesize': 16})
    num_dims = GT.shape[1]
    time_steps = np.arange(GT.shape[0])

    if output_names is None:
        output_names = [
            "X",
            "Y",
            "Z",
            "elevation",
            "shoulder elev.",
            "shoulder rot.",
            "elbow angle",
        ]
        output_names = output_names + [
            "X vel",
            "Y vel",
            "Z vel",
            "elev. vel",
            "shoulder elev. vel",
            "shoulder rot. vel",
            "elbow angle vel",
        ]
        output_names = output_names[0:num_dims]

    max_cols = 4  # Maximum number of columns per row
    num_rows = int(np.ceil(num_dims / max_cols))  # Determine number of rows

    fig, axs = plt.subplots(
        num_rows, max_cols, figsize=(4 * max_cols, 3 * num_rows), sharex=True
    )
    axs = axs.flatten()  # Flatten in case of fewer subplots

    for i in range(num_dims):
        ax = axs[i]
        ax.plot(
            time_steps,
            GT[:, i],
            label="Ground Truth",
            color="black",
            linestyle="-",
            linewidth=2,
        )
        ax.plot(
            time_steps,
            prediction[:, i],
            label="Pred",
            color="tab:blue",
            linestyle="--",
            linewidth=2,
        )

        if prediction_vib is not None:
            ax.plot(
                time_steps,
                prediction_vib[:, i],
                label="Pred (Vib)",
                color="tab:red",
                linestyle="-.",
                linewidth=2,
            )

        ax.set_title(f"{output_names[i]}")
        # add xlabel to last row
        if i % max_cols == num_rows:
            ax.set_xlabel("Time steps")

        # ax.grid(True, linestyle="--", alpha=0.6)

    # Hide empty subplots if num_dims is not a multiple of max_cols
    for j in range(num_dims, len(axs)):
        fig.delaxes(axs[j])

    axs[0].legend()
    fig.suptitle(f"trial {num} pred", fontweight="bold")
    plt.tight_layout()

    if path_prefix:
        plt.savefig(f"{path_prefix}_outputs.pdf", dpi=300, bbox_inches="tight")

    plt.show()


def plot_wristpred(GT, prediction, num=0, path_prefix=None):
    # compute the predicted xyz position from the angles, then plot the GT xyz, predicted xyz and predicted xyz from joint
    _, elbow_pos_pred, wrist_pos_pred = get_shoulder_elbow_wrist_loc(prediction)
    _, _, wrist_pos_pred_GT = get_shoulder_elbow_wrist_loc(GT)

    output_names = [
        "X",
        "Y",
        "Z",
        "elbow angle",
        "elevation",
        "shoulder elev.",
        "shoulder rot.",
    ]
    time_steps = np.arange(GT.shape[0])
    # Plot wrist coords from GT, pred and pred from FK
    num_rows = 1
    max_cols = 3
    fig, axs = plt.subplots(
        num_rows, max_cols, figsize=(4 * max_cols, 3 * num_rows), sharex=True
    )
    axs = axs.flatten()  # Flatten in case of fewer subplots

    for i in range(3):
        ax = axs[i]
        ax.plot(
            time_steps,
            GT[:, i],
            label="GT",
            color="black",
            linestyle="-",
            linewidth=2,
        )
        ax.plot(
            time_steps,
            prediction[:, i],
            label="Pred",
            color="tab:blue",
            linestyle="-",
            linewidth=2,
        )
        ax.plot(
            time_steps,
            wrist_pos_pred[:, i],
            label="Pred from angles",
            color="tab:blue",
            linestyle="--",
            linewidth=2,
        )
        ax.plot(
            time_steps,
            wrist_pos_pred_GT[:, i],
            label="Pred from GT angles",
            color="tab:red",
            linestyle="--",
            linewidth=2,
        )

        ax.set_title(f"{output_names[i]}")
        ax.set_xlabel("Time Steps")
        # ax.grid(True, linestyle="--", alpha=0.6)

    axs[-1].legend()

    fig.suptitle(f"trial {num} pred", fontweight="bold")
    plt.tight_layout()

    if path_prefix:
        plt.savefig(f"{path_prefix}_wrist.pdf", dpi=300, bbox_inches="tight")

    plt.show()
    return


def plot_3D_traj(
    modes, path_prefix, pred_coords, pred_vib, upper_arm_length=33, input_data="ELBOW"
):

    # setup the 3D plot
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
    fig.set_size_inches(23, 13)

    things_to_plot = []

    # plot end-effector position
    if (
        modes["coord"] == "both"
        or modes["coord"] == "truth"
        or modes["coord"] == "both_v"
    ):
        (scat1,) = ax.plot(
            [], [], [], linestyle="", marker="o", markersize=10, color="blue"
        )
        (line1,) = ax.plot([], [], [], color="blue", label="Truth End-effector")
        things_to_plot.append(scat1)
        things_to_plot.append(line1)

        # plot elbow and shoulder
        if modes["joints"]:
            if modes["data"] == "PCR":
                shoulder_from_joints_t, elbow_from_joints_t = get_shoulder_elbow_loc(
                    wrist, upper_arm_length
                )
            elif modes["data"] == "ELBOW":
                shoulder_from_joints_t, elbow_from_joints_t = shoulder, elbow
            (scat2,) = ax.plot(
                [], [], [], linestyle="", marker="o", markersize=10, color="black"
            )
            (line2,) = ax.plot([], [], [], color="black", label="Truth shoulder")
            (scat3,) = ax.plot(
                [], [], [], linestyle="", marker="o", markersize=10, color="red"
            )
            (line3,) = ax.plot([], [], [], color="red", label="Truth elbow")
            (line4,) = ax.plot([], [], [], color="black", label="Truth arm")
            things_to_plot.append(scat2)
            things_to_plot.append(line2)
            things_to_plot.append(scat3)
            things_to_plot.append(line3)
            things_to_plot.append(line4)

    # plot end-effector position
    if (
        modes["coord"] == "both"
        or modes["coord"] == "pred"
        or modes["coord"] == "both_v"
    ):
        (scat4,) = ax.plot(
            [], [], [], linestyle="", marker="o", markersize=10, color="darkblue"
        )
        (line5,) = ax.plot([], [], [], color="darkblue", label="Predicted End-effector")
        things_to_plot.append(scat4)
        things_to_plot.append(line5)

        # plot elbow and shoulder
        if modes["joints"]:
            shoulder_from_joints_p, elbow_from_joints_p = get_shoulder_elbow_loc(
                pred_coords, upper_arm_length
            )
            (scat5,) = ax.plot(
                [], [], [], linestyle="", marker="o", markersize=10, color="gray"
            )
            (line6,) = ax.plot([], [], [], color="gray", label="Predicted shoulder")
            (scat6,) = ax.plot(
                [], [], [], linestyle="", marker="o", markersize=10, color="darkred"
            )
            (line7,) = ax.plot([], [], [], color="darkred", label="Predicted elbow")
            (line8,) = ax.plot([], [], [], color="gray", label="Predicted arm")
            things_to_plot.append(scat5)
            things_to_plot.append(line6)
            things_to_plot.append(scat6)
            things_to_plot.append(line7)
            things_to_plot.append(line8)

    # plot end-effector position with vibrations
    if modes["coord"] == "both_v":
        (scat7,) = ax.plot(
            [], [], [], linestyle="", marker="o", markersize=10, color="cyan"
        )
        (line9,) = ax.plot([], [], [], color="cyan", label="Predicted End-effector Vib")
        things_to_plot.append(scat7)
        things_to_plot.append(line9)

        # plot elbow and shoulder
        if modes["joints"]:
            shoulder_from_joints_pv, elbow_from_joints_pv = get_shoulder_elbow_loc(
                pred_vib, upper_arm_length
            )
            (scat8,) = ax.plot(
                [],
                [],
                [],
                linestyle="",
                marker="o",
                markersize=10,
                color="gainsboro",
            )
            (line10,) = ax.plot(
                [], [], [], color="gainsboro", label="Predicted shoulder Vib"
            )
            (scat9,) = ax.plot(
                [], [], [], linestyle="", marker="o", markersize=10, color="pink"
            )
            (line11,) = ax.plot([], [], [], color="pink", label="Predicted elbow Vib")
            (line12,) = ax.plot(
                [], [], [], color="gainsboro", label="Predicted arm Vib"
            )
            things_to_plot.append(scat8)
            things_to_plot.append(line10)
            things_to_plot.append(scat9)
            things_to_plot.append(line11)
            things_to_plot.append(line12)

    def animation(i):

        # plot end-effector position
        if (
            modes["coord"] == "both"
            or modes["coord"] == "truth"
            or modes["coord"] == "both_v"
        ):
            # scat1.set_data_3d(wrist[i,0],wrist[i,1],wrist[i,2])
            scat1.set_data_3d(
                wrist[i : i + 1, 0], wrist[i : i + 1, 1], wrist[i : i + 1, 2]
            )
            line1.set_data_3d(wrist[:i, 0], wrist[:i, 1], wrist[:i, 2])

            # plot elbow and shoulder
            if modes["joints"]:

                # plot the arm - truth
                # scat2.set_data_3d(shoulder_from_joints_t[i,0],shoulder_from_joints_t[i,1],shoulder_from_joints_t[i,2])
                scat2.set_data_3d(
                    shoulder_from_joints_t[i : i + 1, 0],
                    shoulder_from_joints_t[i : i + 1, 1],
                    shoulder_from_joints_t[i : i + 1, 2],
                )
                line2.set_data_3d(
                    shoulder_from_joints_t[:i, 0],
                    shoulder_from_joints_t[:i, 1],
                    shoulder_from_joints_t[:i, 2],
                )
                # scat3.set_data_3d(elbow_from_joints_t[i,0],elbow_from_joints_t[i,1],elbow_from_joints_t[i,2])
                scat3.set_data_3d(
                    elbow_from_joints_t[i : i + 1, 0],
                    elbow_from_joints_t[i : i + 1, 1],
                    elbow_from_joints_t[i : i + 1, 2],
                )
                line3.set_data_3d(
                    elbow_from_joints_t[:i, 0],
                    elbow_from_joints_t[:i, 1],
                    elbow_from_joints_t[:i, 2],
                )
                line4.set_data_3d(
                    [
                        shoulder_from_joints_t[i, 0],
                        elbow_from_joints_t[i, 0],
                        wrist[i, 0],
                    ],
                    [
                        shoulder_from_joints_t[i, 1],
                        elbow_from_joints_t[i, 1],
                        wrist[i, 1],
                    ],
                    [
                        shoulder_from_joints_t[i, 2],
                        elbow_from_joints_t[i, 2],
                        wrist[i, 2],
                    ],
                )

        # plot end-effector position
        if (
            modes["coord"] == "both"
            or modes["coord"] == "pred"
            or modes["coord"] == "both_v"
        ):
            # scat4.set_data_3d(pred_coords[i,0],pred_coords[i,1],pred_coords[i,2])
            scat4.set_data_3d(
                pred_coords[i : i + 1, 0],
                pred_coords[i : i + 1, 1],
                pred_coords[i : i + 1, 2],
            )
            line5.set_data_3d(
                pred_coords[:i, 0], pred_coords[:i, 1], pred_coords[:i, 2]
            )

            # plot elbow and shoulder
            if modes["joints"]:

                # plot the arm - predicted
                # scat5.set_data_3d(shoulder_from_joints_p[i,0],shoulder_from_joints_p[i,1],shoulder_from_joints_p[i,2])
                scat5.set_data_3d(
                    shoulder_from_joints_p[i : i + 1, 0],
                    shoulder_from_joints_p[i : i + 1, 1],
                    shoulder_from_joints_p[i : i + 1, 2],
                )
                line6.set_data_3d(
                    shoulder_from_joints_p[:i, 0],
                    shoulder_from_joints_p[:i, 1],
                    shoulder_from_joints_p[:i, 2],
                )
                # scat6.set_data_3d(elbow_from_joints_p[i,0],elbow_from_joints_p[i,1],elbow_from_joints_p[i,2])
                scat6.set_data_3d(
                    elbow_from_joints_p[i : i + 1, 0],
                    elbow_from_joints_p[i : i + 1, 1],
                    elbow_from_joints_p[i : i + 1, 2],
                )
                line7.set_data_3d(
                    elbow_from_joints_p[:i, 0],
                    elbow_from_joints_p[:i, 1],
                    elbow_from_joints_p[:i, 2],
                )
                line8.set_data_3d(
                    [
                        shoulder_from_joints_p[i, 0],
                        elbow_from_joints_p[i, 0],
                        pred_coords[i, 0],
                    ],
                    [
                        shoulder_from_joints_p[i, 1],
                        elbow_from_joints_p[i, 1],
                        pred_coords[i, 1],
                    ],
                    [
                        shoulder_from_joints_p[i, 2],
                        elbow_from_joints_p[i, 2],
                        pred_coords[i, 2],
                    ],
                )

        # plot end-effector position
        if modes["coord"] == "both_v":
            # scat7.set_data_3d(pred_vib[i,0],pred_vib[i,1],pred_vib[i,2])
            scat7.set_data_3d(
                pred_vib[i : i + 1, 0],
                pred_vib[i : i + 1, 1],
                pred_vib[i : i + 1, 2],
            )
            line9.set_data_3d(pred_vib[:i, 0], pred_vib[:i, 1], pred_vib[:i, 2])

            # plot elbow and shoulder
            if modes["joints"]:

                # plot the arm - predicted
                # scat8.set_data_3d(shoulder_from_joints_pv[i,0],shoulder_from_joints_pv[i,1],shoulder_from_joints_pv[i,2])
                scat8.set_data_3d(
                    shoulder_from_joints_pv[i : i + 1, 0],
                    shoulder_from_joints_pv[i : i + 1, 1],
                    shoulder_from_joints_pv[i : i + 1, 2],
                )
                line10.set_data_3d(
                    shoulder_from_joints_pv[:i, 0],
                    shoulder_from_joints_pv[:i, 1],
                    shoulder_from_joints_pv[:i, 2],
                )
                # scat9.set_data_3d(elbow_from_joints_pv[i,0],elbow_from_joints_pv[i,1],elbow_from_joints_pv[i,2])
                scat9.set_data_3d(
                    elbow_from_joints_pv[i : i + 1, 0],
                    elbow_from_joints_pv[i : i + 1, 1],
                    elbow_from_joints_pv[i : i + 1, 2],
                )
                line11.set_data_3d(
                    elbow_from_joints_pv[:i, 0],
                    elbow_from_joints_pv[:i, 1],
                    elbow_from_joints_pv[:i, 2],
                )
                line12.set_data_3d(
                    [
                        shoulder_from_joints_pv[i, 0],
                        elbow_from_joints_pv[i, 0],
                        pred_vib[i, 0],
                    ],
                    [
                        shoulder_from_joints_pv[i, 1],
                        elbow_from_joints_pv[i, 1],
                        pred_vib[i, 1],
                    ],
                    [
                        shoulder_from_joints_pv[i, 2],
                        elbow_from_joints_pv[i, 2],
                        pred_vib[i, 2],
                    ],
                )

        return things_to_plot

    # scaling
    ax.set_xlim(-50, 50)
    ax.set_ylim(-50, 50)
    ax.set_zlim(-50, 50)

    # setup plot
    ax.legend()
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")

    if modes["data"] == "ELBOW":
        ax.view_init(elev=30, azim=-150)
    elif modes["data"] == "PCR":
        ax.view_init(elev=30, azim=-139)

    if modes["animate"]:
        # generate the animation and save
        # anim = ani.FuncAnimation(fig, animation, repeat=True, frames=wrist.shape[0] - 1, interval=1)
        # if path_to_save != None: anim.save(path_to_save+f"/{indx}_PCR_animation.gif", writer=ani.PillowWriter(fps=240, bitrate=1800))
        # Calculate the number of frames based on desired duration and frame rate
        frame_rate = 240  # Adjust frame rate as needed (higher for smoother animation)
        if input_data == "FLAG":
            duration = MAX_DURATION  # Desired animation duration in seconds
            num_frames = int(duration * frame_rate)
            num_frames = min(num_frames, wrist.shape[0] - 1)
        else:
            num_frames = wrist.shape[0] - 1

        # Generate the animation
        anim = ani.FuncAnimation(
            fig, animation, repeat=True, frames=num_frames, interval=1
        )

        if path_prefix != None:

            # Save the animation with specified settings
            anim.save(
                path_prefix + "_animation.gif",
                writer=ani.PillowWriter(fps=frame_rate, bitrate=1800),
            )
    else:
        animation(wrist.shape[0] - 1)
        if path_prefix != None:
            plt.savefig(path_prefix + "_3D.png")


def plotter(
    modes,
    path_to_save=None,
    elbow=None,
    shoulder=None,
    wrist=None,
    pred_coords=None,
    pred_vib=None,
    spatiotemproal_input=None,
    spatiotemproal_input_vib=None,
    muscle_spindles=None,
    muscle_spindles_norm=None,
    muscle_spindles_vib=None,
    muscle_spindles_norm_vib=None,
    indx=0,
    upper_arm_length=33,
    start=None,
    end=None,
    vib_config=None,
    input_data="ELBOW",
):
    """
    visualizes the data for this project. however, since there are many ways to do so, "mode" will be used to know
    which data will need to be passed and used

    Arguments:
        modes: {"data": {"PCR", "ELBOW"},                           whether the PCR or elbow angle data sets are used
                "plot": {"traj", "muscles", "both", "both_v"},      whether to plot the 3D trajectory and/or muscle length data, "both_v" will also plot "pred_vib" and "muscle_vib"
                "coord": {"truth", "pred", "both", "both_v"},       whether to plot the coordinates as a function of time, "both_v" will also plot "pred_vib" and "muscle_vib"
                "joints": bool                                      whether to use the joint data to plot the shoulder and elbow (True) or just the coordinates (False)
                "animate": bool                                     whether or not to animate
                "spindles": bool                                    if spindle data is passed
                "show": {True, False}}                              whether to call plt.show()
        path_to_save: string, folder name of location to save graphs and plotting data, None will not save anything
        elbow: list of floats of shape (time, 3) to plot the elbow trajectory
        wrist: list of floats of shape (time, 3) to plot the wrist trajectory
        shoulder: list of floats of shape (time, 3) to plot the shoulder trajectory
        muscle: list of floats of shape (time, num_muscles, 2) containing the muscle lengths in [:,:,0] and velocities in [:,:,1]
        joints_config: list of floats of shape (time, 4) with the shoulder R, L, E Euler angles and the elbow joint angle
        pred_joints: same as joints_config but from the model's prediction
        pred_joints_vib: same as pred_joints but from the prediction with the vibrations
        pred_coords: list of floats of shape (time, 3) of the predicted wrist trajectory
        pred_vib: list of floats of shape (time, 3) to plotted with pred_coords
        muscle_vib: list of floats of shape (time, num_muscles, 2) to be plotted with muscle
        indx: any key to differentiate the saved file name
        key: string, name of dataset being used
    """

    if path_to_save != None:
        path_prefix = path_to_save + f"/{indx}_{input_data}"
        if vib_config["is"]:
            freq = vib_config["VIB_FREQ"]
            path_prefix = path_prefix + f"_vib_{freq}"

    if modes["plot"] == "traj" or modes["plot"] == "both":
        plot_3D_traj(
            modes, path_prefix, pred_coords, pred_vib, upper_arm_length, input_data
        )

    if modes["plot"] == "muscles" or modes["plot"] == "both":

        # set up grid of plots
        if modes["spindles"]:
            fig1, (
                (ax9, ax10, ax1, ax3),
                (ax11, ax12, ax2, ax4),
                (ax5, ax7, ax6, ax8),
            ) = plt.subplots(3, 4)
        else:
            fig1, ((ax3, ax1, ax7, ax5), (ax4, ax2, ax6, ax8)) = plt.subplots(2, 4)
        fig1.set_size_inches(23, 13)

        colour_map = [cm.tab20(x) for x in np.linspace(0, 1, 25)]

        # plot the muscle lengths and velocities
        for i in range(25):
            ax1.plot(spatiotemproal_input[i, :, 0].T, color=colour_map[i])
            ax2.plot(spatiotemproal_input[i, :, 1].T, color=colour_map[i])
            if modes["coord"] == "both_v":
                ax1.plot(
                    spatiotemproal_input_vib[i, :, 0].T,
                    color=colour_map[i],
                    linestyle="dashed",
                )
                ax2.plot(
                    spatiotemproal_input_vib[i, :, 1].T,
                    color=colour_map[i],
                    linestyle="dashed",
                )
        if modes["spindles"]:
            for i in range(25):
                ax9.plot(muscle_spindles[i, :, 0].T, color=colour_map[i])
                ax11.plot(muscle_spindles[i, :, 1].T, color=colour_map[i])
                if modes["coord"] == "both_v":
                    ax9.plot(
                        muscle_spindles_vib[i, :, 0].T,
                        color=colour_map[i],
                        linestyle="dashed",
                    )
                    ax11.plot(
                        muscle_spindles_vib[i, :, 1].T,
                        color=colour_map[i],
                        linestyle="dashed",
                    )
            for i in range(25):
                ax10.plot(muscle_spindles_norm[i, :, 0].T, color=colour_map[i])
                ax12.plot(muscle_spindles_norm[i, :, 1].T, color=colour_map[i])
                if modes["coord"] == "both_v":
                    ax10.plot(
                        muscle_spindles_norm_vib[i, :, 0].T,
                        color=colour_map[i],
                        linestyle="dashed",
                    )
                    ax12.plot(
                        muscle_spindles_norm_vib[i, :, 1].T,
                        color=colour_map[i],
                        linestyle="dashed",
                    )

            ax1.set_ylabel("Ia firing rate")
            ax2.set_ylabel("II firing rate")
            ax9.set_ylabel("Fiber length (mm)")
            ax11.set_ylabel("Fiber velocity (mm/s)")
            ax10.set_ylabel("Fiber length (mm/mm)")
            ax12.set_ylabel("Fiber velocity ((mm/s)/mm)")
            ax9.set_xlabel("Time steps")
            ax10.set_xlabel("Time steps")
            ax11.set_xlabel("Time steps")
            ax12.set_xlabel("Time steps")
        else:
            ax1.set_ylabel("Fiber length (mm)")
            ax2.set_ylabel("Fiber velocity (mm/s)")

        ax1.set_xlabel("Time steps")
        ax2.set_xlabel("Time steps")

        # only plot the muscles change wrt elbow angles
        count = 0
        plot_angle_flag = False
        if (
            modes["data"] == "PCR"
            and modes["joints"]
            and (shoulder == None or elbow == None)
        ):
            shoulder, elbow = get_shoulder_elbow_loc(wrist, upper_arm_length)
            plot_angle_flag = True
        if modes["data"] == "ELBOW" or plot_angle_flag:
            plot_angle_flag = True
            angles = get_angle(shoulder[:, :3], elbow[:, :3], wrist[:, :3])
            if modes["spindles"]:
                count += 1
                for i in range(25):
                    ax3.plot(
                        spatiotemproal_input[i, :, 0].T * vib_config["norm_Ia"][0]
                        + vib_config["norm_Ia"][1],
                        color=colour_map[i],
                    )
                    ax4.plot(
                        spatiotemproal_input[i, :, 1].T * vib_config["norm_II"][0]
                        + vib_config["norm_II"][1],
                        label=f"{MUSCLE_NAMES_FOR_ELBOW[i]}_vib",
                        color=colour_map[i],
                    )
                if modes["coord"] == "both_v":
                    for i in range(25):
                        ax3.plot(
                            spatiotemproal_input_vib[i, :, 0].T
                            * vib_config["norm_Ia"][0]
                            + vib_config["norm_Ia"][1],
                            color=colour_map[i],
                            linestyle="dashed",
                        )
                        ax4.plot(
                            spatiotemproal_input_vib[i, :, 1].T
                            * vib_config["norm_II"][0]
                            + vib_config["norm_II"][1],
                            label=f"{MUSCLE_NAMES_FOR_ELBOW[i]}_vib",
                            color=colour_map[i],
                            linestyle="dashed",
                        )
            else:
                for i in range(25):
                    if (
                        spatiotemproal_input[i, :, 0].max()
                        != spatiotemproal_input[i, :, 0].min()
                    ):
                        ax3.plot(
                            angles, spatiotemproal_input[i, :, 0].T, color=colour_map[i]
                        )
                        ax4.plot(
                            angles,
                            spatiotemproal_input[i, :, 1].T,
                            label=f"{MUSCLE_NAMES_FOR_ELBOW[i]}",
                            color=colour_map[i],
                        )
                        count += 1
                if modes["coord"] == "both_v":
                    for i in range(25):
                        if (
                            spatiotemproal_input[i, :, 0].max()
                            != spatiotemproal_input[i, :, 0].min()
                        ):
                            ax3.plot(
                                angles,
                                spatiotemproal_input_vib[i, :, 0].T,
                                color=colour_map[i],
                                linestyle="dashed",
                            )
                            ax4.plot(
                                angles,
                                spatiotemproal_input_vib[i, :, 1].T,
                                label=f"{MUSCLE_NAMES_FOR_ELBOW[i]}_vib",
                                color=colour_map[i],
                                linestyle="dashed",
                            )
                            count += 1

        if modes["spindles"]:
            ax3.set_xlabel("Time steps")
            ax4.set_xlabel("Time steps")
            ax3.set_ylabel("Ia firing rate")
            ax4.set_ylabel("II firing rate")
        else:
            ax3.set_xlabel("Elbow angle (deg)")
            ax4.set_xlabel("Elbow angle (deg)")
            ax3.set_ylabel("Fiber length (mm)")
            ax4.set_ylabel("Fiber velocity (mm/s)")

        if count != 0:
            ax4.legend(ncol=4)

        # plot the wrist coordinates prediction and ground truth
        if (
            modes["coord"] == "both"
            or modes["coord"] == "truth"
            or modes["coord"] == "both_v"
        ):
            ax5.plot(wrist[:, 0], label="xt", color="blue", linestyle="dashed")
            ax5.plot(wrist[:, 1], label="yt", color="red", linestyle="dashed")
            ax5.plot(wrist[:, 2], label="zt", color="black", linestyle="dashed")
            if modes["data"] == "PCR" and modes["joints"]:
                ax7.plot(wrist[:, 6], color="blue", label="Truth End-effector")
            elif modes["data"] == "ELBOW" or plot_angle_flag:
                ax7.plot(angles, color="blue", label="Truth End-effector")
            ax6.plot([0] * len(wrist[:, 0]), color="black", label="x-axis")
            ax8.plot([0] * len(wrist[:, 0]), color="black", label="x-axis")
        if (
            modes["coord"] == "both"
            or modes["coord"] == "pred"
            or modes["coord"] == "both_v"
        ):
            ax5.plot(pred_coords[:, 0], label="xp", color="darkblue")
            ax5.plot(pred_coords[:, 1], label="yp", color="darkred")
            ax5.plot(pred_coords[:, 2], label="zp", color="gray")
            if modes["data"] == "PCR" and modes["joints"]:
                ax7.plot(
                    pred_coords[:, 6], color="green", label="Predicted End-effector"
                )
                ax6.plot(
                    pred_coords[:, 6] - wrist[:, 6],
                    color="green",
                    label="Predicted End-effector",
                )
            elif modes["data"] == "ELBOW" or plot_angle_flag:
                ax7.plot(
                    get_angle(shoulder, elbow, pred_coords[:, :3]),
                    color="green",
                    label="Predicted End-effector",
                )
                ax6.plot(
                    get_angle(shoulder, elbow, pred_coords[:, :3]) - angles,
                    color="green",
                    label="Predicted End-effector",
                )
        if modes["coord"] == "both_v":
            ax5.plot(pred_vib[:, 0], label="xpv", color="cyan")
            ax5.plot(pred_vib[:, 1], label="ypv", color="pink")
            ax5.plot(pred_vib[:, 2], label="zpv", color="gainsboro")
            if modes["data"] == "PCR" and modes["joints"]:
                ax7.plot(
                    pred_vib[:, 6], color="orange", label="Predicted End-effector Vib"
                )
                ax6.plot(
                    pred_vib[:, 6] - wrist[:, 6],
                    color="orange",
                    label="Predicted End-effector Vib",
                )
                ax8.plot(
                    pred_vib[:, 6] - pred_coords[:, 6],
                    color="orange",
                    label="Predicted End-effector Vib",
                )
            elif modes["data"] == "ELBOW" or plot_angle_flag:
                ax7.plot(
                    get_angle(shoulder, elbow, pred_vib[:, :3]),
                    color="orange",
                    label="Predicted End-effector Vib",
                )
                ax6.plot(
                    get_angle(shoulder, elbow, pred_vib[:, :3]) - angles,
                    color="orange",
                    label="Predicted End-effector Vib",
                )
                ax8.plot(
                    get_angle(shoulder, elbow, pred_vib[:, :3])
                    - get_angle(shoulder, elbow, pred_coords[:, :3]),
                    color="orange",
                    label="Predicted End-effector Vib",
                )
        ax5.legend()
        ax5.set_xlabel("Time steps")
        ax5.set_ylabel("Wrist coordinate")
        ax7.legend()
        ax7.set_xlabel("Time steps")
        ax7.set_ylabel("Elbow angle (degrees)")
        ax6.legend()
        ax6.set_xlabel("Time steps")
        ax6.set_ylabel("Elbow angle difference wrt Truth (degrees)")
        ax8.legend()
        ax8.set_xlabel("Time steps")
        ax8.set_ylabel("Elbow angle difference wrt non-vibrated (degrees)")

        if start != None and end != None:
            ax1.axvline(x=start)
            ax1.axvline(x=end)
            ax2.axvline(x=start)
            ax2.axvline(x=end)
            ax5.axvline(x=start)
            ax5.axvline(x=end)
            ax6.axvline(x=start)
            ax6.axvline(x=end)
            ax7.axvline(x=start)
            ax7.axvline(x=end)
            ax8.axvline(x=start)
            ax8.axvline(x=end)

            if modes["spindles"]:
                ax3.axvline(x=start)
                ax3.axvline(x=end)
                ax4.axvline(x=start)
                ax4.axvline(x=end)
                ax9.axvline(x=start)
                ax9.axvline(x=end)
                ax10.axvline(x=start)
                ax10.axvline(x=end)
                ax11.axvline(x=start)
                ax11.axvline(x=end)
                ax12.axvline(x=start)
                ax12.axvline(x=end)

        fig1.tight_layout()

        if path_to_save != None:
            plt.savefig(path_prefix + "_2D.png")

            shoulder_from_joints_t, elbow_from_joints_t = get_shoulder_elbow_loc(
                wrist, upper_arm_length
            )
            shoulder_from_joints_p, elbow_from_joints_p = get_shoulder_elbow_loc(
                pred_coords, upper_arm_length
            )
            ### Florian ###
            if modes["joints"]:
                plot_movement(
                    path_prefix,
                    shoulder_from_joints_t,
                    elbow_from_joints_t,
                    wrist[:, 0:3],
                    shoulder_from_joints_p,
                    elbow_from_joints_p,
                    pred_coords[:, 0:3],
                    wrist[:, 6],
                    pred_coords[:, 6],
                )

    # save the graphing data
    if path_to_save != None:
        with open(path_prefix + "_coords.pkl", "wb") as myfile:
            pkl.dump(
                {
                    "wrist": wrist,
                    "pred_vib": pred_vib,
                    "pred_coords": pred_coords,
                    "elbow": elbow,
                    "shoulder": shoulder,
                    "spatiotemproal_input": spatiotemproal_input,
                    "spatiotemproal_input_vib": spatiotemproal_input_vib,
                },
                myfile,
            )

    # only show if no other plots are being plotted
    if modes["show"]:
        plt.show()

    # to avoid clogging memory
    plt.close("all")


def get_angle(a, b, c, proj=None, mat=None):
    """
    uses the cosine law to find the angle at point b

    Arguments:
        a, b, c: numpy arrays of coordinates of shape [num_coord, 3]

    Returns:
        angles: list of angles of shape [num_coord]
    """

    # saving the data
    angles = []
    for i in range(len(a)):

        # find vector meeting at point b
        ab = b[i] - a[i]
        cb = b[i] - c[i]
        if proj:
            ab = np.matmul(mat, ab)
            cb = np.matmul(mat, cb)

        # use cosine law
        numerator = np.dot(ab, cb)
        denom = np.linalg.norm(ab) * np.linalg.norm(cb)
        angles.append(np.arccos(numerator / denom) * 180 / np.pi)

    return np.array(angles)


def get_shoulder_elbow_loc(outputs, upper_arm_length):
    shoulder_loc = np.zeros((outputs.shape[0], 3))
    elbow_loc = np.array(
        [
            transform()
            .dot(roty(outputs[i, 3]))  # elbow angle
            .dot(rotz(outputs[i, 4]))  # elevation
            .dot(roty(-outputs[i, 3]))  # elbow angle
            .dot(roty(outputs[i, 5]))  # shoulder elevation
            .dot(np.array(([0, -upper_arm_length, 0])))
            for i in range(outputs.shape[0])
        ]
    )
    return shoulder_loc, elbow_loc


def get_shoulder_elbow_wrist_loc(
    outputs, upper_arm_length=UPPER_ARM_LENGTH, forearm_length=FOREARM_LENGTH
):
    shoulder_to_world = np.array([[0, 0, -1], [-1, 0, 0], [0, 1, 0]])
    shoulder_loc = np.zeros((outputs.shape[0], 3))  # Assume shoulder is at origin

    elbow_angle_idx = 6
    elevation_idx = 3
    shoulder_elevation_idx = 4
    shoulder_rotation_idx = 5
    # elbow_angle_idx = 3
    # elevation_idx = 0
    # shoulder_elevation_idx = 1
    # shoulder_rotation_idx = 2

    def shoulder_rotation(elv_angle, shoulder_elv, shoulder_rot):
        return (
            roty(elv_angle)
            .dot(rotz(shoulder_elv))
            .dot(roty(-elv_angle))
            .dot(roty(shoulder_rot))
        )

    def elbow_rotation(elbow_flexion):
        return rotx(elbow_flexion)

    # Define initial joint locations:
    elbow = np.array([0, -upper_arm_length, 0])
    hand = np.array([0, -forearm_length, 0])

    elbow_loc = [
        shoulder_to_world.dot(
            shoulder_rotation(
                outputs[i, elevation_idx],
                outputs[i, shoulder_elevation_idx],
                outputs[i, shoulder_rotation_idx],
            ).dot(elbow)
        )
        for i in range(outputs.shape[0])
    ]
    elbow_loc = np.array(elbow_loc)

    wrist_loc = [
        shoulder_to_world.dot(
            shoulder_rotation(
                outputs[i, elevation_idx],
                outputs[i, shoulder_elevation_idx],
                outputs[i, shoulder_rotation_idx],
            ).dot(elbow_rotation(outputs[i, elbow_angle_idx]).dot(hand) + elbow)
        )
        for i in range(outputs.shape[0])
    ]
    wrist_loc = np.array(wrist_loc)

    return shoulder_loc, elbow_loc, wrist_loc


def rotx(angle):
    angle = angle * np.pi / 180
    return np.array(
        [
            [1, 0, 0],
            [0, np.cos(angle), -np.sin(angle)],
            [0, np.sin(angle), np.cos(angle)],
        ]
    )


def roty(angle):
    angle = angle * np.pi / 180
    return np.array(
        [
            [np.cos(angle), 0, np.sin(angle)],
            [0, 1, 0],
            [-np.sin(angle), 0, np.cos(angle)],
        ]
    )


def transform():
    return np.array([[0, 0, -1], [-1, 0, 0], [0, 1, 0]])


def rotz(angle):
    angle = angle * np.pi / 180
    return np.array(
        [
            [np.cos(angle), -np.sin(angle), 0],
            [np.sin(angle), np.cos(angle), 0],
            [0, 0, 1],
        ]
    )

